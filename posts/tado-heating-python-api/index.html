<!doctype html><html lang=en><head><title>Getting more out of your Tado heating system with Python and the Tado API Â· Sam Harrison
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta http-equiv=Content-Security-Policy content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self' https://utteranc.es; img-src 'self' https://storage.ko-fi.com https://samharrison7.goatcounter.com/count; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/; script-src 'self' 'unsafe-inline' https://gc.zgo.at https://storage.ko-fi.com https://cdn.jsdelivr.net https://utteranc.es; connect-src 'self' https://samharrison7.goatcounter.com/count;"><meta name=author content="Sam Harrison"><meta name=description content="How to control your Tado heating system with Python and the Tado API"><meta name=keywords content="environmental scientist,environmental modelling,research software,blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://samharrison.science/images/sam.jpg"><meta name=twitter:title content="Getting more out of your Tado heating system with Python and the Tado API"><meta name=twitter:description content="How to control your Tado heating system with Python and the Tado API"><meta property="og:url" content="https://samharrison.science/posts/tado-heating-python-api/"><meta property="og:site_name" content="Sam Harrison"><meta property="og:title" content="Getting more out of your Tado heating system with Python and the Tado API"><meta property="og:description" content="How to control your Tado heating system with Python and the Tado API"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-30T00:00:00+00:00"><meta property="article:tag" content="Api"><meta property="article:tag" content="Tado"><meta property="article:tag" content="Python"><meta property="og:image" content="https://samharrison.science/images/sam.jpg"><link rel=canonical href=https://samharrison.science/posts/tado-heating-python-api/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.aa5ef26fa979d6793724ae2dbd71efa94fd16cb1c5c7db3b6651f21f9892a5fd.css integrity="sha256-ql7yb6l51nk3JK4tvXHvqU/RbLHFx9s7ZlHyH5iSpf0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/override.min.6240859aa8ee939a6a00894c1f5d26b7d034a33df2928b1fca4aa26ed939e8fb.css integrity="sha256-YkCFmqjuk5pqAIlMH10mt9A0oz3ykosfykqibtk56Ps=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><img class=header-avatar src=/images/sam-header.jpg>
<a class=navigation-title href=/>Sam Harrison
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/my-research/>My Research</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://samharrison.science/posts/tado-heating-python-api/>Getting more out of your Tado heating system with Python and the Tado API</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2023-10-30T00:00:00Z>30 October 2023
</time></span><span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
10-minute read</span></div><div class=tags><span class=tag><a href=/tags/api/>api</a>
</span><span class=tag><a href=/tags/tado/>tado</a>
</span><span class=tag><a href=/tags/python/>python</a></span></div></div></header><div><p>We have recently installed a Tado thermostat to control our heating system. Tado is a &ldquo;smart&rdquo; heating system, in the sense that it is internet connected and lets you control your heating via its own app. The app is surprisingly good, but lacking in a few places, and so this got me wondering whether Tado had an API, and whether I could leverage this to get a bit more out of our heating system. The two specific things I wanted to achieve were:</p><ul><li>Be able to access historic temperature measurements. The app lets you do this on a day-by-day basis, but I would like a bit more flexibility to e.g. view a month at a time. I also don&rsquo;t trust that the data will always be available, though I&rsquo;m happy to be corrected here.</li><li>Better control over scheduling. The app has a pretty versatile scheduler, but as soon as you start getting fiddly with your schedule (e.g. specifying multiple small time blocks), it gets very fiddly to use.</li></ul><h2 id=the-tado-api>The Tado API
<a class=heading-link href=#the-tado-api><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Having a quick Google around, it seems that Tado does have an API, but it is not supported or documented. Fortunately, some kind folks have created various libraries, and the <a href=https://libtado.readthedocs.io/en/latest/ target=_blank>Python library <code>libtado</code></a> caught my attention, mainly because it has a function to <code>set_schedule_blocks</code> (more on that later).</p><p>Installation was easy: <code>pip install libtado</code>. Authentication was also surprisingly easy (I hope they employ some rate limiting to stop brute force attacks!), just requiring a client secret that can currently be found by visiting this page - <a href=https://app.tado.com/env.js target=_blank>https://app.tado.com/env.js</a> - alongside your username and password.</p><p>To connect to the API, I set my username, password and client secret as environment variables and called these from my script:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a>import</span> <span style=color:#0aa;text-decoration:underline>os</span>
</span></span><span style=display:flex><span><span style=color:#00a>from</span> <span style=color:#0aa;text-decoration:underline>libtado.api</span> <span style=color:#00a>import</span> Tado
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Get auth tokens from env vars and pass to the API</span>
</span></span><span style=display:flex><span>auth = {
</span></span><span style=display:flex><span>    <span style=color:#a50>&#39;username&#39;</span>: os.environ[<span style=color:#a50>&#39;TADO_USERNAME&#39;</span>],
</span></span><span style=display:flex><span>    <span style=color:#a50>&#39;password&#39;</span>: os.environ[<span style=color:#a50>&#39;TADO_PASSWORD&#39;</span>],
</span></span><span style=display:flex><span>    <span style=color:#a50>&#39;secret&#39;</span>: os.environ[<span style=color:#a50>&#39;TADO_CLIENT_SECRET&#39;</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>api = Tado(**auth)
</span></span></code></pre></div><p>Note that this interface is slightly different to that specified in <code>libtado</code>&rsquo;s documentation, which says to <code>import tado.api</code>, but this didn&rsquo;t work for me.</p><p>To get access to the measurement data recorded by your thermostat, the easiest (and possibly only) way seems to use the daily reports. <code>libtado</code> provides a convenient <code>get_report()</code> function to do this, so let&rsquo;s use this to get today&rsquo;s measurements so far, and plot these on a graph. Note that you need to specify the zone ID for the report, but we only have one zone at the moment and so the ID is just <code>1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a>import</span> <span style=color:#0aa;text-decoration:underline>numpy</span> <span style=color:#00a>as</span> <span style=color:#0aa;text-decoration:underline>np</span>
</span></span><span style=display:flex><span><span style=color:#00a>import</span> <span style=color:#0aa;text-decoration:underline>pandas</span> <span style=color:#00a>as</span> <span style=color:#0aa;text-decoration:underline>pd</span>
</span></span><span style=display:flex><span><span style=color:#00a>import</span> <span style=color:#0aa;text-decoration:underline>plotly.express</span> <span style=color:#00a>as</span> <span style=color:#0aa;text-decoration:underline>px</span>
</span></span><span style=display:flex><span><span style=color:#00a>from</span> <span style=color:#0aa;text-decoration:underline>datetime</span> <span style=color:#00a>import</span> date
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Get the report for today</span>
</span></span><span style=display:flex><span>report = api.get_report(zone=<span style=color:#099>1</span>,
</span></span><span style=display:flex><span>                        date=date.today().strftime(<span style=color:#a50>&#39;%Y-%m-</span><span style=color:#a50>%d</span><span style=color:#a50>&#39;</span>))
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># get_report returns a dict with all of today&#39;s data, including</span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># weather and heating demand data as well as the measured temperature</span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># and humidity</span>
</span></span><span style=display:flex><span>report.keys()
</span></span></code></pre></div><pre><code>dict_keys(['zoneType', 'interval', 'hoursInDay', 'measuredData', 'stripes', 'settings', 'callForHeat', 'weather'])
</code></pre><p>Let&rsquo;s pull out the measured temperatures from this. The data is represented in quite a fiddly hierarchical dictionary structure, but a simple list comprehension can be used to translate this into NumPy arrays for plotting:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>temp_data = report[<span style=color:#a50>&#39;measuredData&#39;</span>][<span style=color:#a50>&#39;insideTemperature&#39;</span>][<span style=color:#a50>&#39;dataPoints&#39;</span>]
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Use list comprehensions to create arrays of temperature and times</span>
</span></span><span style=display:flex><span>temp_ts = np.array([x[<span style=color:#a50>&#39;value&#39;</span>][<span style=color:#a50>&#39;celsius&#39;</span>] <span style=color:#00a>for</span> x <span style=color:#00a>in</span> temp_data])
</span></span><span style=display:flex><span>times = np.array([x[<span style=color:#a50>&#39;timestamp&#39;</span>] <span style=color:#00a>for</span> x <span style=color:#00a>in</span> temp_data])
</span></span></code></pre></div><p>We can quickly plot these using Plotly (or another plotting library of your choice!). I first create a Pandas DataFrame in order to make the string to datetime conversion a little simpler.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#aaa;font-style:italic># Save in a dataframe and convert the times to proper timestamps</span>
</span></span><span style=display:flex><span>df = pd.DataFrame({<span style=color:#a50>&#39;Time&#39;</span>: times, <span style=color:#a50>&#39;Temperature&#39;</span>: temp_ts})
</span></span><span style=display:flex><span>df[<span style=color:#a50>&#39;Time&#39;</span>] = pd.to_datetime(df[<span style=color:#a50>&#39;Time&#39;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Plot</span>
</span></span><span style=display:flex><span>fig = px.line(df, <span style=color:#a50>&#39;Time&#39;</span>, <span style=color:#a50>&#39;Temperature&#39;</span>)
</span></span><span style=display:flex><span>fig.show(renderer=<span style=color:#a50>&#39;png&#39;</span>, width=<span style=color:#099>860</span>)
</span></span></code></pre></div><p><img alt=png src=output_8_0.png></p><h2 id=saving-historical-data-to-a-database>Saving historical data to a database
<a class=heading-link href=#saving-historical-data-to-a-database><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>One of the main reasons I wanted to use the Tado API was to be able to save historical data to my own database, to make it easy to view different date ranges and just in case Tado limits the amount of historical data it stores.</p><p>There are a tonnes of ways you could do this, e.g:</p><ul><li>Simply loop over daily reports and dump them to CSV files (<code>df.to_csv()</code>), maybe concatenating them into one big CSV as you go.</li><li>Use the Google Sheets API to save the data into a Google Sheets file.</li><li>Create a &ldquo;proper&rdquo; database and store the data in there.</li></ul><p>The latter seemed the most flexible option. Tado ouputs a fair amount of data (measurements every 15 minutes), and a proper database will more easily cope with this as the database grows over the coming years. I am <em>not</em> a database expert, but SQLite seemed a reasonable choice and after a quick Google, it seems that I can get Pandas to do most of the work for me here, with its convenient <code>df.to_sql()</code> function. So, let&rsquo;s create one big DataFrame to dump to an SQLite file.</p><p>Firstly, I need to loop through all of the days that I want to store in the database. We have only been using the Tado thermostat for 5 days, so that is straighforward. Then I pull the data into separate DataFrames, and finally concatenate them.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>dfs = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Loop over the days in October that I want the reports for</span>
</span></span><span style=display:flex><span><span style=color:#00a>for</span> day <span style=color:#00a>in</span> <span style=color:#0aa>range</span>(<span style=color:#099>24</span>, <span style=color:#099>30</span>):
</span></span><span style=display:flex><span>    <span style=color:#aaa;font-style:italic># Get the report for this day</span>
</span></span><span style=display:flex><span>    report = api.get_report(zone=<span style=color:#099>1</span>,
</span></span><span style=display:flex><span>                            date=<span style=color:#a50>f</span><span style=color:#a50>&#39;2023-10-</span><span style=color:#a50>{</span>day<span style=color:#a50>}</span><span style=color:#a50>&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#aaa;font-style:italic># Get the temperature and humidity data from the report</span>
</span></span><span style=display:flex><span>    temp_data = report[<span style=color:#a50>&#39;measuredData&#39;</span>][<span style=color:#a50>&#39;insideTemperature&#39;</span>][<span style=color:#a50>&#39;dataPoints&#39;</span>]
</span></span><span style=display:flex><span>    humidity_data = report[<span style=color:#a50>&#39;measuredData&#39;</span>][<span style=color:#a50>&#39;humidity&#39;</span>][<span style=color:#a50>&#39;dataPoints&#39;</span>]
</span></span><span style=display:flex><span>    <span style=color:#aaa;font-style:italic># Use list comprehensions to create arrays of temperature, humidity and times</span>
</span></span><span style=display:flex><span>    temp_ts = np.array([x[<span style=color:#a50>&#39;value&#39;</span>][<span style=color:#a50>&#39;celsius&#39;</span>] <span style=color:#00a>for</span> x <span style=color:#00a>in</span> temp_data])
</span></span><span style=display:flex><span>    <span style=color:#aaa;font-style:italic># Multiply humidity by 100 to get a percentage</span>
</span></span><span style=display:flex><span>    humidity_ts = np.array([x[<span style=color:#a50>&#39;value&#39;</span>] * <span style=color:#099>100</span> <span style=color:#00a>for</span> x <span style=color:#00a>in</span> humidity_data])
</span></span><span style=display:flex><span>    <span style=color:#aaa;font-style:italic># Here I am relying on temperature and humidity being measured at the</span>
</span></span><span style=display:flex><span>    <span style=color:#aaa;font-style:italic># same time points</span>
</span></span><span style=display:flex><span>    times = np.array([x[<span style=color:#a50>&#39;timestamp&#39;</span>] <span style=color:#00a>for</span> x <span style=color:#00a>in</span> temp_data])
</span></span><span style=display:flex><span>    <span style=color:#aaa;font-style:italic># Save in a dataframe and convert the times to proper timestamps</span>
</span></span><span style=display:flex><span>    df_ = pd.DataFrame({<span style=color:#a50>&#39;Time&#39;</span>: times, <span style=color:#a50>&#39;Temperature&#39;</span>: temp_ts, <span style=color:#a50>&#39;Humidity&#39;</span>: humidity_ts})
</span></span><span style=display:flex><span>    <span style=color:#aaa;font-style:italic># Convert time from string to a proper datetime</span>
</span></span><span style=display:flex><span>    df_[<span style=color:#a50>&#39;Time&#39;</span>] = pd.to_datetime(df_[<span style=color:#a50>&#39;Time&#39;</span>])
</span></span><span style=display:flex><span>    <span style=color:#aaa;font-style:italic># Add to the list of datafames to concat</span>
</span></span><span style=display:flex><span>    dfs.append(df_)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Combine the individual daily reports into one big dataframe</span>
</span></span><span style=display:flex><span>df = pd.concat(dfs, ignore_index=<span style=color:#00a>True</span>)
</span></span><span style=display:flex><span>df
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><div><style scoped>.dataframe tbody tr th:only-of-type{vertical-align:middle}<pre><code>.dataframe tbody tr th{vertical-align:top}.dataframe thead th{text-align:right}</code></pre><p></style></p><table border=1 class=dataframe><thead><tr style=text-align:right><th></th><th>Time</th><th>Temperature</th><th>Humidity</th></tr></thead><tbody><tr><th>0</th><td>2023-10-24 13:06:30.865000+00:00</td><td>15.63</td><td>66.6</td></tr><tr><th>1</th><td>2023-10-24 13:15:00+00:00</td><td>15.56</td><td>66.9</td></tr><tr><th>2</th><td>2023-10-24 13:30:00+00:00</td><td>15.53</td><td>67.1</td></tr><tr><th>3</th><td>2023-10-24 13:45:00+00:00</td><td>15.50</td><td>67.4</td></tr><tr><th>4</th><td>2023-10-24 14:00:00+00:00</td><td>15.50</td><td>67.4</td></tr><tr><th>...</th><td>...</td><td>...</td><td>...</td></tr><tr><th>536</th><td>2023-10-29 23:15:00+00:00</td><td>16.94</td><td>69.7</td></tr><tr><th>537</th><td>2023-10-29 23:30:00+00:00</td><td>16.96</td><td>69.5</td></tr><tr><th>538</th><td>2023-10-29 23:45:00+00:00</td><td>16.89</td><td>69.6</td></tr><tr><th>539</th><td>2023-10-30 00:00:00+00:00</td><td>16.78</td><td>69.6</td></tr><tr><th>540</th><td>2023-10-30 00:15:00+00:00</td><td>16.75</td><td>69.6</td></tr></tbody></table><p>541 rows Ã 3 columns</p></div><p>Now we can save this to a new table in a new SQLite database. We will use the <code>sqlalchemy</code> library (<code>pip install sqlalchemy</code> or similar) to create a database connection (which is what Pandas expects), which in our case will be to a local file called <code>heating.db</code>. Then we pass this to Pandas&rsquo; <code>to_sql()</code> function to create a new table (also called &ldquo;heating&rdquo;) from our DataFrame:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#00a>import</span> <span style=color:#0aa;text-decoration:underline>sqlalchemy</span> <span style=color:#00a>as</span> <span style=color:#0aa;text-decoration:underline>db</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Create the database engine</span>
</span></span><span style=display:flex><span>engine = db.create_engine(<span style=color:#a50>&#39;sqlite:///heating.db&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Connect to the database</span>
</span></span><span style=display:flex><span><span style=color:#00a>with</span> engine.connect() <span style=color:#00a>as</span> con:
</span></span><span style=display:flex><span>    <span style=color:#aaa;font-style:italic># Save our dataframe to a table called &#34;heating&#34;</span>
</span></span><span style=display:flex><span>    df.to_sql(<span style=color:#a50>&#39;heating&#39;</span>, con, if_exists=<span style=color:#a50>&#39;replace&#39;</span>)
</span></span></code></pre></div><p>To double check this has saved correctly, let&rsquo;s load the data from the database and produce a graph of the full timeseries:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#aaa;font-style:italic># Connect and read the heating table to a dataframe</span>
</span></span><span style=display:flex><span><span style=color:#00a>with</span> engine.connect() <span style=color:#00a>as</span> con:
</span></span><span style=display:flex><span>    df = pd.read_sql_table(<span style=color:#a50>&#39;heating&#39;</span>, con)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Plot</span>
</span></span><span style=display:flex><span>fig = px.line(df, <span style=color:#a50>&#39;Time&#39;</span>, <span style=color:#a50>&#39;Temperature&#39;</span>)
</span></span><span style=display:flex><span>fig.show(renderer=<span style=color:#a50>&#39;png&#39;</span>, width=<span style=color:#099>860</span>)
</span></span></code></pre></div><p><img alt=png src=output_14_0.png></p><p>Perfect - I now have a database with all of our historical temperature and humidity data in it! Of course, in practice you would probably want to re-run this to append new data on a daily-or-so basis, but setting up scheduled jobs is beyond this post. You might also want to pull down some of the other useful data from Tado, such as outside temperatures, weather conditions, and heating demand.</p><h2 id=setting-a-schedule>Setting a schedule
<a class=heading-link href=#setting-a-schedule><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The second reason I wanted to use the Tado API was to have a bit of easier control over scheduling. The Tado app is reasonably good for schedules with big time blocks, but fiddly with smaller and/or numerous time blocks. It is also quite limited in the ability to define multiple different schedules and easily switch between them.</p><p>Firstly, I need to do a bit of digging to figure out how the Tado API would like the schedule blocks formatted. I am figuring that the JSON format should be the same as that returned by <code>get_schedule_blocks()</code>, and so let&rsquo;s first call that on an existing schedule to see what the data structure looks like. For this demo, I have set up an arbitrary schedule that is 20C from 7:30am to 9:30pm, and 18C at other times:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#aaa;font-style:italic># Firstly, I get the ID of the schedule I am currently using</span>
</span></span><span style=display:flex><span>schedule_id = api.get_schedule(zone=<span style=color:#099>1</span>)[<span style=color:#a50>&#39;id&#39;</span>]
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Then I get the blocks from this schedule</span>
</span></span><span style=display:flex><span>blocks = api.get_schedule_blocks(zone=<span style=color:#099>1</span>, schedule=schedule_id)
</span></span><span style=display:flex><span>blocks
</span></span></code></pre></div><pre><code>[{'dayType': 'MONDAY_TO_SUNDAY',
  'start': '00:00',
  'end': '07:30',
  'geolocationOverride': False,
  'setting': {'type': 'HEATING',
   'power': 'ON',
   'temperature': {'celsius': 18.0, 'fahrenheit': 64.4}}},
 {'dayType': 'MONDAY_TO_SUNDAY',
  'start': '07:30',
  'end': '21:30',
  'geolocationOverride': False,
  'setting': {'type': 'HEATING',
   'power': 'ON',
   'temperature': {'celsius': 20.0, 'fahrenheit': 68.0}}},
 {'dayType': 'MONDAY_TO_SUNDAY',
  'start': '21:30',
  'end': '00:00',
  'geolocationOverride': False,
  'setting': {'type': 'HEATING',
   'power': 'ON',
   'temperature': {'celsius': 18.0, 'fahrenheit': 64.4}}}]
</code></pre><p>From this, I can see that Tado wants a list of time blocks that have <code>dayType</code>, <code>start</code>, <code>end</code>, <code>geolocationOverride</code> and <code>setting</code> keys, with the temperature itself being contained in the <code>setting</code> key. That should be pretty easy to replicate.</p><p>Let&rsquo;s take a hypothetical scenario: I want the heating to come on for 20 minutes of every hour, from 7am until 10pm. When it&rsquo;s on, I want it to try and reach 17C, and when it&rsquo;s off, I will let it go down to 14C. Rather than writing all of this out, it&rsquo;s easier to generate such a schedule programmatically, using the schema we&rsquo;ve just figured out:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>blocks = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Define a function to set each block based on the schema</span>
</span></span><span style=display:flex><span><span style=color:#00a>def</span> <span style=color:#0a0>set_block</span>(start, end, temperature):
</span></span><span style=display:flex><span>    <span style=color:#00a>return</span> {
</span></span><span style=display:flex><span>        <span style=color:#a50>&#39;dayType&#39;</span>: <span style=color:#a50>&#39;MONDAY_TO_SUNDAY&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a50>&#39;start&#39;</span>: start,
</span></span><span style=display:flex><span>        <span style=color:#a50>&#39;end&#39;</span>: end,
</span></span><span style=display:flex><span>        <span style=color:#a50>&#39;geolocationOverride&#39;</span>: <span style=color:#00a>False</span>,
</span></span><span style=display:flex><span>        <span style=color:#a50>&#39;setting&#39;</span>: {
</span></span><span style=display:flex><span>            <span style=color:#a50>&#39;temperature&#39;</span>: {<span style=color:#a50>&#39;celsius&#39;</span>: temperature},
</span></span><span style=display:flex><span>            <span style=color:#a50>&#39;type&#39;</span>: <span style=color:#a50>&#39;HEATING&#39;</span>,
</span></span><span style=display:flex><span>            <span style=color:#a50>&#39;power&#39;</span>: <span style=color:#a50>&#39;ON&#39;</span>,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Set the start block (midnight to 7am)</span>
</span></span><span style=display:flex><span>blocks.append(set_block(<span style=color:#a50>&#39;00:00&#39;</span>, <span style=color:#a50>&#39;07:00&#39;</span>, <span style=color:#099>14.0</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Loop through each hour between 7am and 10pm and add to the list of blocks</span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># for the two blocks that will be within that hour</span>
</span></span><span style=display:flex><span><span style=color:#00a>for</span> h <span style=color:#00a>in</span> <span style=color:#0aa>range</span>(<span style=color:#099>7</span>, <span style=color:#099>22</span>):
</span></span><span style=display:flex><span>    start = <span style=color:#a50>f</span><span style=color:#a50>&#39;</span><span style=color:#a50>{</span>h<span style=color:#a50>:</span><span style=color:#a50>02d</span><span style=color:#a50>}</span><span style=color:#a50>:00&#39;</span>
</span></span><span style=display:flex><span>    off = <span style=color:#a50>f</span><span style=color:#a50>&#39;</span><span style=color:#a50>{</span>h<span style=color:#a50>:</span><span style=color:#a50>02d</span><span style=color:#a50>}</span><span style=color:#a50>:20&#39;</span>
</span></span><span style=display:flex><span>    end = <span style=color:#a50>f</span><span style=color:#a50>&#39;</span><span style=color:#a50>{</span>h + <span style=color:#099>1</span><span style=color:#a50>:</span><span style=color:#a50>02d</span><span style=color:#a50>}</span><span style=color:#a50>:00&#39;</span>
</span></span><span style=display:flex><span>    on_block = set_block(start, off, <span style=color:#099>17.0</span>)
</span></span><span style=display:flex><span>    off_block = set_block(off, end, <span style=color:#099>14.0</span>)
</span></span><span style=display:flex><span>    blocks.append(on_block)
</span></span><span style=display:flex><span>    blocks.append(off_block)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa;font-style:italic># Set the end block (10pm to midnight)</span>
</span></span><span style=display:flex><span>blocks.append(set_block(<span style=color:#a50>&#39;22:00&#39;</span>, <span style=color:#a50>&#39;00:00&#39;</span>, <span style=color:#099>14.0</span>))
</span></span></code></pre></div><p><code>libtado</code> has a <code>set_schedule_blocks()</code> function. However, I have not managed to get this to work without a 403 error (see <a href=https://github.com/germainlefebvre4/libtado/issues/201 target=_blank>this issue</a> - <strike>maybe it will be closed by the time you&rsquo;re reading this!</strike> this issue has now been solved in <a href=https://github.com/germainlefebvre4/libtado/releases/tag/3.7.8 target=_blank>release 3.7.8</a>!). Instead, I am going to access the internal <code>libtado.api</code> function <code>_api_call</code>, and pass a slightly different URL to that used by <code>set_schedule_blocks()</code>. Notably, a &ldquo;day type&rdquo; parameter is also passed, which is either &ldquo;MONDAY_TO_SUNDAY&rdquo;, &ldquo;MONDAY_TO_FRIDAY&rdquo; or a day of the week, depending on whether you are setting a one (Monday to Sunday), three (Monday to Friday, Saturday, Sunday) or seven day schedule.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>_ = api._api_call(
</span></span><span style=display:flex><span>    <span style=color:#a50>&#34;homes/</span><span style=color:#a50>%i</span><span style=color:#a50>/zones/</span><span style=color:#a50>%i</span><span style=color:#a50>/schedule/timetables/</span><span style=color:#a50>%i</span><span style=color:#a50>/blocks/MONDAY_TO_SUNDAY&#34;</span> % (api.id, <span style=color:#099>1</span>, schedule_id),
</span></span><span style=display:flex><span>    blocks,
</span></span><span style=display:flex><span>    method=<span style=color:#a50>&#34;PUT&#34;</span>,
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Your Tado heating system should now be set with the schedule we just created:</p><p><img alt="Tado heating scheulde" src=tado.png></p><h2 id=what-next>What next?
<a class=heading-link href=#what-next><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Of course, this is just the beginning of what you could do with programmatic control over your home heating system! Integration with other services, such as the open-source <a href=https://www.home-assistant.io/ target=_blank>Home Assistant</a>, could be one way to go. Combining with energy usage data could be an excellent way to optimise your heating system to be as efficient as possible, maybe going as far as creating a machine learning model of your home energy usage to help with the task. But I&rsquo;ll save that for another post!</p></div><footer><span class=mr1>Found this post useful?</span>
<script type=text/javascript src=https://storage.ko-fi.com/cdn/widget/Widget_2.js></script><script type=text/javascript>kofiwidget2.init("Buy me a coffee","#29abe0","B0B1ACSFJ"),kofiwidget2.draw()</script><h3>Comments</h3><div id=utterances-light><script src=https://utteranc.es/client.js repo=samharrison7/samharrison-hugo issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></div><div id=utterances-dark><script src=https://utteranc.es/client.js repo=samharrison7/samharrison-hugo issue-term=pathname label=comment theme=github-dark crossorigin=anonymous async></script></div></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>Â©
2022 -
2025
Sam Harrison
Â·
Powered by <a href=https://gohugo.io/>Hugo</a> & lovingly adapted from the <a href=https://github.com/luizdepra/hugo-coder/>Coder</a> theme
Â·
<a href=https://samharrison.science//about>About this site.</a></section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://samharrison7.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>